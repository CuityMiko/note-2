#### 正则表达式

### ^ 和 $ 使用(行的起始符合和结束符)
**/^cat/**  ： 匹配以 c 作为一行的第一个字符，紧接着一个 a , 再紧接着 t 的文本
**/cat$/**  ：以cat 以cat 结束,后面没有任何字符
**/^cat$/** ：只包含cat，没有其他任何字符串
##### DEMO:
```php
preg_match('/^cat/','catabc',$arr);//cat
preg_match('/cat$/','cat',$arr);//cat
preg_match('/cat$/','catabc',$arr);//false
preg_match('/^cat$/','cat',$arr);//cat
preg_match('/^cat$/','catfk',$arr);//false
```

### 字符组

##### 匹配若干字符之一
如过，我们想匹配单词，如“grey”，同时又不确定它是否写作“gray”，就可以使用正则表达式结构体（construct）"[……]"。它容许使用者列出在某处期望匹配的字符
```
gr[ea]y": 先找到 g,跟着是一个r,然后是一个 a 或者 e,最后是一个y
preg_match('/ca[abc]t/','cact ',$arr);//cact
preg_match('/ca[abc]t/','cabt ',$arr);//cabt
preg_match('/ca[abc]t/','caabt ',$arr);//false
//即只能匹配结构体[]中的一个字符串，或的意思，但必须要有一个
preg_match('/c[abc]ty[aor]u/','catyou',$arr);
preg_match('/ca[0-9]t/','ca3t',$arr);//ca3t 
preg_match('/ca[\d]t/','ca6tbsdf',$arr);//ca6t
```
 在一个字符组中可以列举多个字符。如[123456],匹配 1 到 6 中的任意一个数字。在字符组内部，字符组元字符（character-class metacharacter）"-"(连字符)表示>一个范围。如[0-9],[a-z]等,表示匹 配0 到 9中的任意一个数字，a 到 z 中的任意一个小写字母。和一一列举表单的意思是一样的。“[0-9a-fA-F],[A-Fa-f0-9]”用来匹配>十六进制数字,顺序无所谓。除此外，可以随心所欲把字符范围与普通字符相结合,如“[0-9A-z_!.?]”，能够匹配一个数字，大写字母，下划线，惊叹号，点号，或者问号。
`
注：只有在字符组内部([])，“-” 连字符才是元字符，否则它只能匹配普通连字符号。实际，即使在字符组内部，若它出现在字符组的开头，它也不是元字符，只是一个普通
字符“—”，而不是表示一个范围。同样的道理，问号，和点号通常也被当做元字符，但是在字符粗内，则不是。
`
```php
preg_match('/abc[a-zA-Z0-9_]/','xxxx',$arr);
preg_match('/abc[a-z+()[]A-Z0-9_!.?*]/','xxxx',$arr);//在字符组中，这里的_!.?*是普通字符,-字符如果不是在开头，他就是元字符，如果在开头，则是普通字符，不是范围
```

##### 排除型字符组（文本匹配）
[^……]，这个字符组会匹配任何未列出的字符。如"[^1-6]"，匹配除1到6外的任何字符。字符组开头的"^"，表示排除，这里列出不希望匹配的字符。
`
注：排除型字符组，表示“匹配一个未列出的字符”，而不是 “不要匹配列出的字符”。两种说法看似一样，但略有差异。有一种简单的理解排除型字符组的办法，就是把>他们看做普通字符组，里面包含的是除了“排除型字符组中所有字符”以外的字符。
`
```php
preg_match('/abc[^d]/','abcx',$arr);//abcx
preg_match('/abc[^d]/','abcd',$arr);//false
preg_match('/abc[^0-9]/','abc234242',$arr);//false
preg_match('/abc[^dmnz]/','abcx',$arr);//abcx,即后面不能有^的某个字符
```

#####  用点号匹配任意字符
`
元字符 "." （dot 或 point) 是用来匹配任意字符的字符组的简便写法。如，‘03[-./]19[-./]76’ 匹配 '03/19/76,03-19-76,03.19.76'， 也可以简单尝试，'03.19.76'。
 `
```php
preg_match('/03.19.76/','abc num: 19 203319  7639',$arr);//203319  76
preg_match('/03[-./]19[-./]76/','abc num: 19 203319  7639',$arr);//这样写就只能匹配数字中间是-或.或/分隔的字符，更加精准，但可读性差，难写。
```

##### 匹配任意子表达式
 "|" 是一个非常简捷的元字符，它的意思是“或”。依靠它把不同的子表达式组合成一个总的表达式，而这个总的表达式，又能够匹配任意的子表达式。在这样的组合中，
子表达式称为“多选分支”。如："Bob" 和 "Robert" 是两个表达式， "Bob|Robert" 就是能头同时匹配其中任意一个正则表达式。如："gr[ae]y" 可以写成 "gr(a|e)y"。其>中括号是必须的。否则"gra|ey"，则是匹配 "gra" 或者 "ey"。多选结构可以包含多字符，但是不能跨越括号的界限。如"(fir|1)st.[Ss]treet"。

```php
preg_match('/bei(jing|abc)/','beijingchao',$arr);
preg_match('/bei[abc]/','beiabc',$arr);
//注意上面两个表达式都区别，第一个是将 jing或abc作为一个整体匹配，而第二个则是匹配单个字符a或者b或者c其中一个。

preg_match('/(Li|li)(gui|Gui)(bing|Bing)/','liguibing',$arr);//liguibing
preg_match('/(Li|li)g(ui|ui)b(ing|Ing)/','liguibing',$arr);//liguibing
```
`
在一个包含多选结构的表达式中使用脱字符和美元符的时候要小心。例如 "^From|Subject|Date:." 和 "^(From|Subject|Date):.",前者由3个多选分支构成，所以能匹>配"^From"或"Subject"或"Date:.",后者匹配一行起始位置，然后匹配"From","Subject"或"Date"中的任意一个，然后匹配":."。
`

##### 忽略大小写
忽略大小写，这并非是正则表达式语言的一部分，而是许多工具语言提供的有用的特性。如egrep 的 "-i" 参数。

```
egrep -i '^(From|Subject|Date):' mailbox
preg_match('/^(From|Subject|Date)/i','str....',$arr);
preg_match('/^From:/i','From:ffstr....',$arr);
```

#####     单词分界符（位置匹配）
如果 egrep 支持“元字符序列”，如"\<","\>" 就可以用他们来匹配单词分界的位置。它相当于单词行锚点。用来匹配单词的开头和结束位置。如"\<cat\>" 匹配单词开>头位置，然后是c,a,t三个字母，然后是单词结束的位置。

    注："<"和">" 本身不是元字符，只有当它们和斜线结合的时候，整个序列才具有特殊意义。这就是称为“元字符序列”的原因。重要的是它的特殊意义，而不是字符个数>。

元字符小结

    .      点               单个任意字符
    []     字符组           列出的任意字符
    [^]    排除型字符组     为列出的任意字符
    ^      脱字符           行的起始位置
    $      美元符           行的结束位置
    \<     反斜线-小于      单词的起始位置
    \>     反斜线-大于      单词的结束位置

    |      竖线             匹配分隔两边的任意一个子表达式
    ()     括号             限制竖线的作用范围，等
















