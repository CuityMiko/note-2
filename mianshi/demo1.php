1.COOKIE、SESSION的联系和区别，多台web服务器如何共享SESSION？
        session是通过cookie来工作的，session和cookie之间是通过$_COOKIE['PHPSESSID']来联系的，通过$_COOKIE['PHPSESSID']可
    以知道session的id，从而获取到其他的信息。cookie数据存放在客户的浏览器上,session数据放在服务器上,cookie有大小限制，为4K。

    如何共享SESSION:
    一、利用数据库同步session
        sessionid还是利用cookie机制存储到客户端，但session数据却存放在MySQL服务器上。
        缺点：依赖性太强，Mysql无法工作了影响所有的Web服务器，最影响系统速度。
        
    二、利用cookie同步session
        缺点:1.用户禁用cookie或者cookie泄露，存在安全隐患。
             2.浏览器对单个cookie的数据量大小限制为4K左右，因此会存在数据量的限制问题。
             3.影响带宽性能，降低了页面的访问速度。在高访问量的情况下，用户每次请求时，都要将客户端cookie中的session数据
             发送到服务器，要占用较多的带宽，进而影响访问速度，服务器带宽成本增高。
    
    三、利用memcache、redis同步session
        推荐使用redis内存数据库，因为它比memcache支持更多的数据类型，且支持内存数据备份到磁盘。
        缺点：memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，
        会产生内存碎片，如果存储块不足，还会产生内存溢出。 
    
    三、使用硬件设备
            这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了。
        目前很多门户网站采用这种方式。
        缺点:很明显，贵，不过对于专业或者大型应用来讲，是比较合理并且值得的。
        
2.HTTP协议中的POST和GET有何区别？
    本质:GET用于查询，POST用于修改。
    1）GET请求的数据是放在HTTP包头中的，也就是URL之后，而Post是把提交的数据放在HTTP正文中的。

    2）GET提交的数据比较少，不同浏览器的限制不同，所以要满足最低的IE对其限制为2K+35即2083个字节，而POST可以传送更多的数据
    ，PHP默认一般是2m（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持8
    0KB，IIS5可支持100KB）。

    3）Post的安全性要比Get高，因为Get时，参数数据是明文传输的，而且使用GET的话，
    还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。

3.reqiure的include都可包含文件，二者的区别何在？
    1)当包含的文件不存在时,
    include:代码继续往下执行,报一个warning,
    而require则是报fatal error, 停止执行.

    2)include 一般是放在流程控制的处理部分中。PHP 程序网页在读到 include 的文件时，才将它读进来。
    PHP 程序在执行前，就会先读入 require 所指定引入的文件。

    3)使用require()语句包含的文件不能有返回值。试图在require()语句中返回值将会产生一个解析错误。

    *_once只包含一次,即便多次调用.
    而不加once,则调用一次,包含一次.

    关于效率:
    加once需要检测已加载的文件,效率稍低,
    如果能确认不会多次包含,不必加once


6.打开php.ini中的Safe_mode,会影响哪些参数?至少说出6个.
    开启之后，主要会对系统操作、文件、权限设置等方法产生影响，平常项目基本上也用不到这些方法。主要是用来应对webshell吧，
    减少被人植入webshell所带来的某些安全问题。
        move_uploaded_file() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。
        chdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。
        exec() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用。
        system() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用。
        fopen() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。
        mkdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。
        chmod() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 另外，不能设置 SUID、SGID 和 sticky bits
        mail() 在安全模式下，第五个参数被屏蔽。
        set_time_limit() 在安全模式下不起作用。
        header() 在安全模式下，如果设置了 WWW-Authenticate，当前脚本的 uid 将被添加到该标头的 realm 部分。
        dbmopen() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。
        dbase_open() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。
        escapeshellcmd() 将被作用于此函数的参数上。
        filepro() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。

7.PHP的整型溢出问题是怎样的
        PHP的整型数的字长和平台有关，对于32位的操作系统，最大的整型是有二十多亿，其实就是2的31次方，最小为-2的31次方，PH
    P不支持无符号的整数。64 位平台下的最大值通常是大约 9E18。 如果一个数超出了integer范围，将会被自动解释为float。如果执
    行的运算结果超出了 integer 范围，也会返回 float。你可以通过输出PHP_INT_MAX看到最大整数。（那在java、C中的整型整型溢
    出会怎样）

8.如何理解OOP
     OOP，面向对象编程，包括三个方面，继承性、封装性、多态性，其中最根本的东西就是抽象。
     继承性，即扩展性，通过子类对已经存在的父类进行功能扩展。
     封装性，要求外部不能随意存取对象的内部数据，即对该类中的具体实现做封装，用户不必知道内部的具体实现，只有知道它是干什
             么的，怎么用就好了。
     多态性，就是类的抽象和接口，同一个类能够处理多种类型对象的能力。

9.设计模式
    设计模式，其实就是代码的设计经验的总结和归类，设计模式最早应用与建筑行业，编程的设计模式按最早的GoF所述，
    包括23种设计模式，主要用于面向对象的程序编程。遵循几个设计原则：开闭原则、单一职责原则、里氏替换原则、
    依赖注入、接口分离、迪米特原则、优先使用组合而不是继承等等。包括创建型模式、结构性模式、行为模式三类。

10.HTTP协议1.0及1.1的区别，并简单说下HTTP协议
    HTTP，超文本传输协议。它定义了浏览器和服务器的通信规则。HTTP协议是基于TCP/IP的TCP协议上，现在万维网使用的是HTTP1.1版
    本，其特点包括，C/S模式，请求简单(GET/POST/HEAD),灵活(可以传输任何类型的数据HTML、XML、JSON、自定义等)，无连接(每次连
    接只处理一个请求，从发出请求到收到200状态为止断开连接)，无状态。

    HTTP协议主要包括，响应消息格式、请求消息格式、状态码知识点。

    [响应消息格式]
    HTTP/1.1 200 0K
    Connection:close
    Date: Thu, 13 Oct 2005 03:17:33 GMT
    Server: Apache/2.0.54 (Unix)
    Last—Nodified:Mon,22 Jun 1998 09;23;24 GMT
    Content—Length:682l
    Content—Type:text/html

    这个响应消息分为3部分：1个起始的状态行(status line)，6个头部行、1个包含所请求对象本身的附属体。状态行有3个字段:协议
    版本字段、状态码字段、原因短语字段。

    [请求消息格式]
    GET /somedir/page.html HTTP/1.1
    Host:
    Connection:close
    User-agent:Mozilla/4.0
    Accept-language:zh-cn
    (额外的回车符和换行符)

    该请求消息的第一行称为请求行 (request line)，后续各行都称为头部行(header)。请求行有3个字段:方法字段、URL字段、HTTP版本字段。

    [状态码]参见
    1xx 消息
    2xx 成功
    3xx 重定向
    4xx 请求错误
    5xx 服务器错误

    200 OK。请求已成功，请求所希望的响应头或数据体将随此响应返回。

    301 Moved Permanently。表示请求的网页已永久转移到新位置
    302 Found。表示页面在做临时跳转时返回的状态。
    303 Not Modified。客户的缓存资源是最新的， 要客户端使用缓存。

    403 Forbidden。请求被服务器拒绝了。
    404 Not Found。表示服务器找不到请求的网页，服务器上不存在的网页经常会返回的HTTP状态码。

    500 Internal Server Error。服务器内部错误，一般指代码错误。
    503 Service Unavailable。服务器目前无法为请求提供服务，但过一段时间就可以恢复服务。
    504 Gateway Timeout。与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时。

1.简单说下Apache中rewrite机制和PHP框架中URI路由机制

    1） URL重写，其实就是把用户通过浏览器请求的URL，到了后台，apache根据预先配置的重写规则将该请求指向真正的资源路径，说
    白了就是打马虎眼，把真正的路径改头换面后给用户访问，可问题是这样做有啥用处。
        1、SEO方面。将动态的URL静态化，以满足搜索引擎的胃口。
        2、访问控制。比如，通过重写规则后，客户端不易判断后台程序类型等。
        3、URL重定向。当网站更改域名或增加别名URL后，可以通过规则轻松的指向要访问的URL。

        mod_rewrite 使用基于正则表达式动态的修改传入请求的URL。它可以将URL映射到文件系统路径，也可以将一个URL映射到另一个URL。
    它使用了没有限制数量的规则来操纵URL，每条规则可以包括没有限制数量的附加条件。你可以通过多种方式来检测，如，服务器变量、
    环境变量、HTTP头、时间戳等。
        mod_rewrite 操作整个URL路径，包括path-info的部分。一个重写规则可以被设置在http.conf或者.htaccess中。一个重写规则
    生成的路径可以包括一个请求字符串，或者内部的子程序处理，外部请求的重定向，或者穿透内部代理等。

    2）PHP框架中的URI路由机制，与apache重写类似，一般包括通配符和正则两种规则。让用户可以重新定向(remap)URI处理程序.设定
    你自己的路由规则。


2.MySQL的索引机制，复合索引的使用原则
    （深入浅出MySQL一书中对索引的使用讲的比较细致）
    一般都会用书本中的目录来介绍索引机制，其实有些书本会有专门的快速检索附录，就很类似于数据库的索引。
    MySQL的索引包括4类：主键索引(primary key)、唯一索引(unique)、常规索引(index)、全文索引(fullindex)。
    Show index from table_name; --查看表中的索引
    Show status like 'Handler_read%'  --查看索引的使用情况

    复合索引，一般遵循最左前缀原则，如table_a 的 a b c 三列建复合索引
    create index ind_table_a on table_a(a,b,c);
    那么，只有在条件中用到a,或者a、b,或者a、b、c这样的情况下，才会用到刚建的复合索引。

3.MySQL的表类型及MyISAM与InnoDB的区别
    MySQL常见的表类型(即存储引擎)show engines包 括:MyISAM/Innodb/Memory/Merge/NDB
    其中，MyISAM和Innodb是最常用的两个表类型，各有优势，我们可以根据需求情况选择适合自己的表类型。
    [MyISAM]
        1）每个数据库存储包括3个文件：.frm(表定义)、MYD(数据文件)、MYI(索引文件)
        2）数据文件或索引文件可以指向多个磁盘
        3）Linux的默认引擎，win默认InnoDB
        4）面向非事务类型，避免事务型额外的开销
        5）适用于select、insert密集的表
        6）MyISAM默认锁的调度机制是写优先，可以通过LOW_PRIORITY_UPDATES设置
        7）MyISAM类型的数据文件可以在不同操作系统中COPY，这点很重要，布署的时候方便点。

    [Innodb]
        1）用于事务应用程序
        2）适用于update、delete密集的操作。执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，
           但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。
           DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
        3）引入行级锁和外键的约束
        4）InnoDB不支持FULLTEXT类型的索引


4.简单说下快速排序算法
    基本思想：通过一趟排序将待排序列分割成两部分，其中一部分比另一部分记录小，再分别对这两部分继续快速排序，以达到有序。
    算法实现：设有两个指针low和high，初值为low=1，high=n，设基准值为key(通常选第一个)，则首先从high位置开始向前搜索，
     找到第一个比key小的记录与key交换，然后从low位置向后搜索，找到第一个比key大的记录与基准值交换，重复直至low=high为止。
    第一趟排序结果，key之前的记录值比key之后的记录值小。
        11 25 9  3  16 2   //选择11为key
        2  25 9  3  16 11
        2  11 9  3  16 25
        2  3  9  11 16 25

5.Memcached、redis的使用和理解
    Memcached和redis 都是一个key-value的内存式存储系统，通过hash表来存储检索结果，做到强大的缓存机制。
    下面是从百科中摘录的介绍。具体实践和使用后续再详细介绍。
        Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据
    ，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
        redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、
    set(集合)和zset(有序集合)。

6.strlen()与mb_strlen的作用分别是什么
        PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得 到的只是字符串所占的字节数。对于GB2312的中文编码，strl
    en得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍的差异了（在 UTF-8编码下，一个汉字占3个字节）。
        采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和 strlen类似，只不过它有第二个可选参数用于指定字符编码。
    例如得到UTF-8的字符串$str长度，可以用 mb_strlen($str,'UTF-8')。如果省略第二个参数，则会使用PHP的内部编码。内部编码可
    以通过 mb_internal_encoding()函数得到。
        需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php
    _mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。

7.中文字符串的截取有时会出现乱码，如何解决
    使用mbstring扩展库的mb_substr()截取就不会出现乱码了。
        但是中英文混合的还是会出现问题，例如我要显示一个小图片的简要信息，5 个中文正好，超过 5 个就截取前4再加上 ”…”，
    这样处理中文是没问题了，可是处理英文或数字，这样截取就太短了。还是自己书写截取函数，但效率不如用mbstring扩展库来得高。

8.写出php的public、protected、private三种访问控制模式的区别
    public: 公有类型
            在子类中可以通过 self::属性名(或方法名) 调用public方法或属性, parent::方法名 调用父类方法
    　　　　在实例中可以能过 $obj->属性名(或方法名) 来调用public类型的方法或属性

    protected: 受保护类型
            在子类中可以通过 self::属性名(或方法名) 调用protected方法或属性, parent::属性名(或方法名) 调用父类方法。
            在实例中不能通过 $obj->属性名(或方法名) 来调用protected类型的方法或属性

    private: 私有类型
             该类型的属性或方法只能在该类中使用，
             在该类的实例、子类中、子类的实例中都不能调用私有类型的属性和方法

    self和parent 的区别
      a).在子类中常用到这两个对象。他们的主要区别在于self可以调用父类中的公有或受保护的属性，但parent不可以调用
      b).self:: 它表示当前类的静态成员(方法和属性)与$this不同,$this是指当前对像

9.简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响
    Mysql索引概念：
        说说Mysql索引，看到一个很少比如：索引就好比一本书的目录，它会让你更快的找到内容，显然目录（索引）并不是越多越好，
    假如这本书1000页，有500也是目录，它当然效率低，目录是要占纸张的,而索引是要占磁盘空间的。

    Mysql索引主要有两种结构：B+树和hash.

    hash:hsah索引在mysql比较少用,他以把数据的索引以hash形式组织起来,因此当查找某一条记录的时候,速度非常快.但是因为是hash
    结构,每个键只对应一个值,而且是散列的方式分布.所以他并不支持范围查找和排序等功能.

    B+树:b+tree是mysql使用最频繁的一个索引数据结构,数据结构以平衡树的形式来组织,因为是树型结构,所以更适合用来处理排序,范
    围查找等功能.相对hash索引,B+树在查找单条记录的速度虽然比不上hash索引,但是因为更适合排序等操作,所以他更受用户的欢迎.
    毕竟不可能只对数据库进行单条记录的操作.

    Mysql常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引

    PRIMARY KEY（主键索引）  ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
    UNIQUE(唯一索引)     ALTER TABLE `table_name` ADD UNIQUE (`column`)
    INDEX(普通索引)     ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
    FULLTEXT(全文索引)      ALTER TABLE `table_name` ADD FULLTEXT ( `column` )
    组合索引   ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )

    Mysql各种索引区别：
    普通索引：最基本的索引，没有任何限制
    唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
    主键索引：它是一种特殊的唯一索引，不允许有空值。
    全文索引：仅可用于MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间。
    组合索引：为了更多的提高mysql效率可建立组合索引，遵循"最左前缀"原则。

10.PHP写个函数来解决多线程同时读写一个文件的问题
    用PHP的flock在写文件前先锁上，等写完后解锁，这样就实现了多线程同时读写一个文件避免冲突。大概就是下面这个流程
    /*
    *flock(file,lock,block)
    *file 必需，规定要锁定或释放的已打开的文件
    *lock 必需。规定要使用哪种锁定类型。
    *block 可选。若设置为 1 或 true，则当进行锁定时阻挡其他进程。
    *lock
    *LOCK_SH 要取得共享锁定（读取的程序）
    *LOCK_EX 要取得独占锁定（写入的程序）
    *LOCK_UN 要释放锁定（无论共享或独占）
    *LOCK_NB 如果不希望 flock() 在锁定时堵塞
    */
    $file = fopen("/tmp/lock.txt", "w+");
    if (flock($file,LOCK_EX))
    {
        fwrite($file,'write more words');
        flock($file,LOCK_UN);
    }
    else
    {
        //处理错误逻辑
    }
    fclose($file);
        但在PHP中，flock似乎工作的不是那么好！在多并发情况下，似乎是经常独占资源，不即时释放，或者是根本不释放，造成死锁，
    从而使服务器的cpu占用很高，甚至有时候会让服务器彻底死掉。好像在很多linux/unix系统中，都会有这样的情况发生。所以使用
    flock之前，一定要慎重考虑。
    解决方案:
    方案一：对文件进行加锁时，设置一个超时时间。
    方案二：不使用flock函数，借用临时文件来解决读写冲突的问题。
    方案三：对操作的文件进行随机读写，以降低并发的可能性。
    方案四：将所有要操作的进程放入一个队列中。


4. 索引设计原则：
    1、选择唯一性索引，不重复字段
    2、为经常需要排序、分组和联合操作的字段建立索引，比如经常需要ORDERBY、GROUP BY、DISTINCT和UNION等操作的字段。
    3、为常作为查询条件的字段建立索引
    4、限制索引的数目，每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大
    5、尽量使用数据量少的索引，比如对一个char(100)和char(10)的字段建立全文索引，检索char(10)的效率肯定会好很多
    6、尽量使用前缀来索引，比如TEXT和BLOG类型的字段，进行全文索引会很浪费时间，如果只检索字段的前面若干个字节，这样可以
       提高检索速度
    7、删除不再使用或者很少使用的索引

6.修改session的生存时间
    !必须在session_start()之前!
    $lifTime = 24 * 3600;
    session_set_cookie_params($lifTime);

8.PHP运行机制
    PHP总共有三个模块：内核、Zend引擎、以及扩展层
        PHP内核用来处理请求、文件流、错误处理等相关操作；
        Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它；
        扩展层是一组函数、类库和流，PHP使用它们来执行一些特定的操作。

    PHP的设计理念及特点
        1、多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响，当然，随着
           时代发展，PHP也早已支持多线程模型。
        2、弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才
           会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效，具体会在后面PHP变量中详述。
        3、引擎(Zend)+组件(ext)的模式降低内部耦合。
        4、中间层(sapi)隔绝web server和PHP。

    Sapi
    Sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有：
    1、apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。
    2、cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，
       也是异步webserver所唯一支持的方式。
    3、cli：命令行调用的应用模式


